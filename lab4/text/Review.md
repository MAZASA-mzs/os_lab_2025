# Отчет по Лабораторной работе №4

## Задание 1: Убийство процессов по таймауту

В программу `parallel_min_max` была добавлена обработка сигнала `SIGALRM`.

**Реализация:**
1.  Добавлен аргумент командной строки `--timeout`.
2.  При запуске родительский процесс сохраняет `PID` всех созданных детей в массив.
3.  Если указан таймаут, взводится будильник через `alarm(timeout)`.
4.  При срабатывании таймера вызывается обработчик сигнала, который проходит по массиву `child_pids` и посылает `SIGKILL` (сигнал 9) каждому ребенку.
5.  Родительский процесс использует `wait(NULL)` для очистки ресурсов убитых детей.

## Задание 2: Зомби-процессы

Создана программа `zombie.c`, демонстрирующая появление зомби-процессов.

**Объяснение:**
* **Как появляются:** Зомби — это процесс, который завершил выполнение (вызвал `exit`), но его родитель еще не считал его код возврата с помощью системного вызова `wait` или `waitpid`. Запись о процессе остается в таблице процессов ОС, чтобы хранить код завершения.
* **Чем опасны:** Они не потребляют память или процессорное время (кроме записи в таблице процессов), но таблица процессов имеет ограниченный размер. Большое количество зомби может исчерпать лимит PID, и создание новых процессов станет невозможным (Fork bomb).
* **Как избавиться:** Родитель должен вызывать `wait`. Если родитель умирает раньше зомби, зомби "усыновляется" процессом `init` (PID 1), который автоматически делает `wait`.

## Задание 3: Структура виртуальной памяти

Была скомпилирована и запущена программа `process_memory.c`.

**Переменные:**
* `etext`: Адрес конца сегмента текста (Text Segment). Здесь хранится исполняемый код программы. Этот сегмент обычно доступен только для чтения.
* `edata`: Адрес конца сегмента инициализированных данных (Data Segment). Здесь хранятся глобальные и статические переменные, которые были явно инициализированы программистом.
* `end`: Адрес конца сегмента неинициализированных данных (BSS - Block Started by Symbol). Здесь хранятся глобальные переменные, не имеющие явной инициализации (по умолчанию они зануляются).

Все, что находится после `end`, — это "куча" (Heap), которая растет в сторону увеличения адресов при вызове `malloc`.

## Задание 5: Параллельная сумма (Pthreads)

Разработана программа `parallel_sum`, использующая библиотеку `pthread`.

**Детали реализации:**
* Логика суммирования вынесена в отдельный модуль `sum.c` (функция `Sum`).
* Массив генерируется с помощью `GenerateArray`.
* Массив логически разбивается на равные части между потоками.
* Каждый поток (`pthread_create`) считает сумму своей части.
* Главный поток ожидает завершения всех (`pthread_join`) и суммирует частичные результаты.
* Замеряется время работы только вычислительной части (без генерации массива).

## Сборка
Для сборки всех заданий используется `makefile`:
```bash
make all