### 1\. Подготовка: Модификация `mutex.c`

Вставьте этот блок в начало файла `mutex.c` (или замените места, где были закомментированные строки), чтобы код реагировал на флаг компиляции `WITH_MUTEX`.

**Что нужно изменить в `mutex.c` (внутри функций `do_one_thing` и `do_another_thing`):**

```c
// Вместо закомментированных строк используйте #ifdef:

#ifdef WITH_MUTEX
    pthread_mutex_lock(&mut);
#endif

    // ... (код инкремента и цикла) ...

#ifdef WITH_MUTEX
    pthread_mutex_unlock(&mut);
#endif
```

-----

### 2\. Файл `Makefile`

Скопируйте это в файл с именем `Makefile`:

```makefile
CC = gcc
CFLAGS = -Wall
LIBS = -lpthread

# Собираем всё сразу
all: mutex_unsafe mutex_safe factorial deadlock

# Задание 1: Небезопасная версия (без мьютекса)
mutex_unsafe: mutex.c
	$(CC) $(CFLAGS) -o mutex_unsafe mutex.c $(LIBS)

# Задание 1: Безопасная версия (с флагом -DWITH_MUTEX)
mutex_safe: mutex.c
	$(CC) $(CFLAGS) -DWITH_MUTEX -o mutex_safe mutex.c $(LIBS)

# Задание 2: Факториал
factorial: factorial.c
	$(CC) $(CFLAGS) -o factorial factorial.c $(LIBS)

# Задание 3: Deadlock
deadlock: deadlock.c
	$(CC) $(CFLAGS) -o deadlock deadlock.c $(LIBS)

clean:
	rm -f mutex_unsafe mutex_safe factorial deadlock
```

-----

### 3\. Обновленный отчёт (`Review.md`)

Вот обновленный текст отчета. Он учитывает, что теперь у нас две разные сборки для первого задания, что выглядит гораздо профессиональнее в лабораторной работе.

````markdown
# Отчет по лабораторной работе №5

## Задание 1: Анализ состояния гонки (Race Condition)

**Цель:** Изучить поведение многопоточной программы при доступе к общему ресурсу без синхронизации и с использованием мьютексов.

Для выполнения задания программа `mutex.c` была модифицирована с использованием директив препроцессора `#ifdef WITH_MUTEX`, что позволяет собирать две разные версии бинарного файла из одного исходного кода.

### Сборка
Использовался `Makefile` для автоматической сборки двух целей:
1.  `mutex_unsafe` — сборка без флага защиты.
2.  `mutex_safe` — сборка с флагом `-DWITH_MUTEX`, который активирует блокировки `pthread_mutex_lock`.

```bash
make all
````

### Результаты экспериментов

#### 1\. Запуск без мьютексов (`./mutex_unsafe`)

При запуске незащищенной версии наблюдается "Состояние гонки".

  * **Ожидаемый результат:** `common = 100` (50 инкрементов от потока 1 + 50 от потока 2).
  * **Фактический результат:** Значение `common` варьируется и часто оказывается меньше 100 (например, 95, 98).
  * **Причина:** Операция инкремента `work++` не является атомарной. Если переключение контекста происходит после чтения переменной, но до её записи, один поток перезаписывает результат работы другого, и инкремент "теряется".

#### 2\. Запуск с мьютексами (`./mutex_safe`)

При запуске защищенной версии результат всегда корректен.

  * **Фактический результат:** `common = 100`.
  * **Причина:** Мьютекс создает критическую секцию. Пока один поток находится между `lock` и `unlock`, второй поток блокируется и ждет своей очереди. Это гарантирует последовательное выполнение операций над общей переменной.

-----

## Задание 2: Параллельный факториал

**Цель:** Написать программу для параллельного вычисления факториала по модулю.

### Реализация (`factorial.c`)

Программа принимает аргументы `-k` (число), `--pnum` (потоки) и `--mod` (модуль).

  * Весь диапазон чисел `[1..k]` делится на равные части между `pnum` потоками.
  * Каждый поток вычисляет локальное произведение в своем диапазоне.
  * **Синхронизация:** Для объединения результатов используется глобальная переменная. Доступ к ней (умножение глобального результата на локальный) защищен мьютексом, чтобы избежать коллизий при одновременном завершении потоков.

### Пример запуска

Вычисление $10! \pmod{1000}$ в 4 потока:

```bash
./factorial -k 10 --pnum=4 --mod=1000
# Результат: Factorial of 10 mod 1000 is: 800
```

-----

## Задание 3: Deadlock (Взаимная блокировка)

**Цель:** Продемонстрировать ситуацию взаимной блокировки.

### Описание реализации (`deadlock.c`)

Созданы два потока и два ресурса (мьютекса А и Б). Смоделирована классическая ситуация Deadlock:

1.  **Поток 1:** Захватывает Мьютекс А -\> `sleep` -\> Пытается захватить Мьютекс Б.
2.  **Поток 2:** Захватывает Мьютекс Б -\> `sleep` -\> Пытается захватить Мьютекс А.

Искусственная задержка (`sleep`) гарантирует, что второй поток успеет захватить свой первый ресурс до того, как первый поток попросит второй ресурс.

### Результат

Программа успешно компилируется, но при запуске зависает навечно после вывода сообщений о захвате первых мьютексов. Завершить её можно только принудительно (Ctrl+C). Это подтверждает возникновение взаимной блокировки.

```
```